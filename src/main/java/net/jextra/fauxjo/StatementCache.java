/*
 * Copyright (C) jextra.net.
 *
 * This file is part of the jextra.net software.
 *
 * The jextra software is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * The jextra software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with the jextra software; if not, write to the Free
 * Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307 USA.
 */

package net.jextra.fauxjo;

import java.lang.reflect.*;
import java.sql.*;
import java.util.*;

public class StatementCache
{
    // ============================================================
    // Fields
    // ============================================================

    private ThreadLocal<Map<Connection, PerConnectionCache>> cache;

    // ============================================================
    // Constructors
    // ============================================================

    public StatementCache()
    {
        cache = new ThreadLocal<>();
    }

    // ============================================================
    // Methods
    // ============================================================

    // ----------
    // public
    // ----------

    public PreparedStatement prepareStatement( Connection conn, String sql )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        PreparedStatement statement = cc.getPreparedStatement( sql );
        if ( statement == null || statement.isClosed() )
        {
            if ( SqlInspector.isInsertStatement( sql ) )
            {
                statement = conn.prepareStatement( sql, Statement.RETURN_GENERATED_KEYS );
            }
            else
            {
                statement = conn.prepareStatement( sql );
            }

            statement = cc.setPreparedStatement( sql, statement );
        }

        return statement;
    }

    public PreparedStatement prepareStatement( Connection conn, String sql, int resultSetType, int resultSetConcurrency )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        PreparedStatement statement = cc.getPreparedStatement( sql );
        if ( statement == null || statement.isClosed() )
        {
            statement = conn.prepareStatement( sql, resultSetType, resultSetConcurrency );

            statement = cc.setPreparedStatement( sql, statement );
        }

        return statement;
    }

    public PreparedStatement prepareStatement( Connection conn, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        PreparedStatement statement = cc.getPreparedStatement( sql );
        if ( statement == null || statement.isClosed() )
        {
            statement = conn.prepareStatement( sql, resultSetType, resultSetConcurrency, resultSetHoldability );

            statement = cc.setPreparedStatement( sql, statement );
        }

        return statement;
    }

    public PreparedStatement prepareStatement( Connection conn, String sql, int autoGeneratedKeys )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        PreparedStatement statement = cc.getPreparedStatement( sql );
        if ( statement == null || statement.isClosed() )
        {
            statement = conn.prepareStatement( sql, autoGeneratedKeys );

            statement = cc.setPreparedStatement( sql, statement );
        }

        return statement;
    }

    public PreparedStatement prepareStatement( Connection conn, String sql, int[] columnIndexes )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        PreparedStatement statement = cc.getPreparedStatement( sql );
        if ( statement == null || statement.isClosed() )
        {
            statement = conn.prepareStatement( sql, columnIndexes );

            statement = cc.setPreparedStatement( sql, statement );
        }

        return statement;
    }

    public PreparedStatement prepareStatement( Connection conn, String sql, String[] columnNames )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        PreparedStatement statement = cc.getPreparedStatement( sql );
        if ( statement == null || statement.isClosed() )
        {
            statement = conn.prepareStatement( sql, columnNames );

            statement = cc.setPreparedStatement( sql, statement );
        }

        return statement;
    }

    public CallableStatement prepareCall( Connection conn, String sql )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        CallableStatement call = cc.getPreparedCall( sql );
        if ( call == null || call.isClosed() )
        {
            call = conn.prepareCall( sql );

            call = cc.setPreparedCall( sql, call );
        }

        return call;
    }

    public CallableStatement prepareCall( Connection conn, String sql, int resultSetType, int resultSetConcurrenc )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        CallableStatement call = cc.getPreparedCall( sql );
        if ( call == null || call.isClosed() )
        {
            call = conn.prepareCall( sql );

            call = cc.setPreparedCall( sql, call );
        }

        return call;
    }

    public CallableStatement prepareCall( Connection conn, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability )
        throws SQLException
    {
        PerConnectionCache cc = getConnCache( conn );
        CallableStatement call = cc.getPreparedCall( sql );
        if ( call == null || call.isClosed() )
        {
            call = conn.prepareCall( sql, resultSetType, resultSetConcurrency, resultSetHoldability );

            call = cc.setPreparedCall( sql, call );
        }

        return call;
    }

    public boolean clear( Connection conn )
        throws SQLException
    {
        if ( conn == null )
        {
            return false;
        }

        Map<Connection, PerConnectionCache> map = cache.get();
        if ( map == null )
        {
            return false;
        }

        boolean workDone = false;
        PerConnectionCache cc = map.get( conn );
        if ( cc != null )
        {
            workDone = cc.clear();
            map.remove( conn );
        }

        return workDone;
    }

    /**
     * Closes and removes all PreparedStatements and PreparedCalls for the active Thread.
     *
     * @return true if any actual work was done and false if there was nothing to remove (most likely already closed).
     */
    public boolean clear()
        throws SQLException
    {
        boolean workDone = false;
        Map<Connection, PerConnectionCache> map = cache.get();
        if ( map != null )
        {
            for ( PerConnectionCache cc : map.values() )
            {
                if ( cc.clear() )
                {
                    workDone = true;
                }
            }
        }
        cache.remove();

        return workDone;
    }

    // ----------
    // private
    // ----------

    private PerConnectionCache getConnCache( Connection conn )
    {
        Map<Connection, PerConnectionCache> map = cache.get();
        if ( map == null )
        {
            map = new WeakHashMap<>();
        }

        PerConnectionCache cc = map.get( conn );
        if ( cc == null )
        {
            cc = new PerConnectionCache();
            map.put( conn, cc );
        }

        return cc;
    }

    // ============================================================
    // Inner Classes
    // ============================================================

    /**
     * Block from actually doing close.
     * Wrap ResultSet in a WrapperResultSet so that getStatement method can return proxy Statement vs default non-wrapped Statement.
     */
    public static class WrappedPreparedStatement implements InvocationHandler
    {
        private PreparedStatement statement;

        public WrappedPreparedStatement( PreparedStatement statement )
        {
            this.statement = statement;
        }

        @Override
        public Object invoke( Object obj, Method method, Object[] args )
            throws Throwable
        {
            if ( "close".equals( method.getName() ) )
            {
                return Void.TYPE;
            }
            else if ( "closeWrapped".equals( method.getName() ) )
            {
                statement.close();

                return Void.TYPE;
            }

            Object retObj = method.invoke( statement, args );

            if ( ResultSet.class.equals( method.getReturnType() ) )
            {
                retObj = Proxy.newProxyInstance( getClass().getClassLoader(), new Class[] { ResultSet.class },
                    new WrappedResultSet( (PreparedStatement) obj, (ResultSet) retObj ) );
            }

            return retObj;
        }
    }

    /**
     * Override getStatement to return proxied Statement vs real Statement.
     */
    public static class WrappedResultSet implements InvocationHandler
    {
        private PreparedStatement parent;
        private ResultSet rs;

        public WrappedResultSet( PreparedStatement parent, ResultSet rs )
        {
            this.parent = parent;
            this.rs = rs;
        }

        @Override
        public Object invoke( Object obj, Method method, Object[] args )
            throws Throwable
        {
            if ( "getStatement".equals( method.getName() ) && Statement.class.equals( method.getReturnType() ) )
            {
                return parent;
            }

            return method.invoke( rs, args );
        }
    }

    public interface ProxyCloser
    {
        void closeWrapped();
    }

    private class PerConnectionCache
    {
        private HashMap<String, PreparedStatement> preparedStatements;
        private HashMap<String, CallableStatement> preparedCalls;

        public PerConnectionCache()
        {
            preparedStatements = new HashMap<>();
            preparedCalls = new HashMap<>();
        }

        public PreparedStatement getPreparedStatement( String sql )
        {
            return preparedStatements.get( sql );
        }

        public PreparedStatement setPreparedStatement( String sql, PreparedStatement statement )
        {
            PreparedStatement proxyStatement = (PreparedStatement) Proxy
                .newProxyInstance( getClass().getClassLoader(), new Class[] { PreparedStatement.class, ProxyCloser.class },
                    new WrappedPreparedStatement( statement ) );

            preparedStatements.put( sql, proxyStatement );

            return proxyStatement;
        }

        public CallableStatement getPreparedCall( String sql )
        {
            return preparedCalls.get( sql );
        }

        public CallableStatement setPreparedCall( String sql, CallableStatement statement )
        {
            CallableStatement proxyCall = (CallableStatement) Proxy
                .newProxyInstance( CallableStatement.class.getClassLoader(), new Class[] { CallableStatement.class, ProxyCloser.class },
                    new WrappedPreparedStatement( statement ) );

            preparedCalls.put( sql, proxyCall );

            return proxyCall;
        }

        public boolean clear()
            throws SQLException
        {
            boolean workDone = false;
            for ( PreparedStatement statement : preparedStatements.values() )
            {
                if ( statement == null )
                {
                    continue;
                }

                if ( !statement.isClosed() )
                {
                    ( (ProxyCloser) statement ).closeWrapped();
                    workDone = true;
                }
            }
            preparedStatements.clear();

            for ( CallableStatement call : preparedCalls.values() )
            {
                if ( call == null )
                {
                    continue;
                }

                if ( !call.isClosed() )
                {
                    ( (ProxyCloser) call ).closeWrapped();
                    workDone = true;
                }
            }
            preparedCalls.clear();

            return workDone;
        }
    }
}
